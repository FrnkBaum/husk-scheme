-- a test program to demonstrate a potential compilation target
--
-- The corresponding scheme code is:
--
-- (write (+ 1 2))
--
-- Compile with:
--
-- ghc -cpp -Wall --make -package ghc -fglasgow-exts -o test hs-src/test.hs hs-src/Language/Scheme/Primitives.hs hs-src/Language/Scheme/Parser.hs hs-src/Language/Scheme/Numerical.hs hs-src/Language/Scheme/Core.hs hs-src/Language/Scheme/Macro.hs hs-src/Language/Scheme/FFI.hs hs-src/Language/Scheme/Macro/Matches.hs
--

module Main where
--import Paths_husk_scheme
import Language.Scheme.Core      -- Scheme Interpreter
import Language.Scheme.Numerical
import Language.Scheme.Primitives
import Language.Scheme.Types     -- Scheme data types
--import Language.Scheme.Variables -- Scheme variable operations
import Control.Monad.Error
import System.IO
--import System.Environment
--import System.Console.Haskeline

main :: IO String --()
main = do
  env <- primitiveBindings
  (runIOThrows $ liftM show $ run env (makeNullContinuation env)) -- >>= putStr ""  -- TODO: args  - see shell.hs


-- TODO: not really sure how to break this up into CPS, but I believe that is required in
-- order for continuations to work properly. Is there a need for a continueEval function,
-- or does the compiler setup everything in CPS style? If the compiler handles it, how does
-- the generated code work with dynamic code that is injected by (load) or via a REPL??
-- or maybe that code is separate so it does not matter??? - no, this cannot be the case because
-- a lambda defined in the compiled code could be passed a continuation from the dynamic
-- code, right?
run :: Env -> LispVal -> IOThrowsError LispVal
run env cont = do
  result <- liftThrows $ numAdd [Number 1, Number 2]
  writeProc (\ port obj -> hPrint port obj) [result]
{-
TODO: eval 1st arg of numAdd, use CPS to eval next one, etc

this might work like prepareApply from Core, although it might be more efficient / necessary to
have that code generated by the compiler, instead of attempting to always thread the code
through the same prepareApply function

f1 :: Env -> LispVal -> [LispVal] -> IOThrowsError LispVal
f1 env cont 
-}

f2 :: Env -> LispVal -> [LispVal] -> IOThrowsError LispVal
f2 env cont vals = do
  writeProc (\ port obj -> hPrint port obj) vals
