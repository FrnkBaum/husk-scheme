Analysis for changes required to implement nary macros

checkLoad
---------
There are two cases here where the pattern is a dotted list. I suggest both just pass the pattern/input to loadLocal for detailed processing

loadLocal
---------
This function needs to be extended to handle loading of an nary macro:
loadLocal outerEnv localEnv identifiers pattern input hasEllipsis outerHasEllipsis = do

There are two cases:

DottedList / List
-----------------

Match case would be:
       ((DottedList ps p), (List (i : is)) -> do

In order to match, we need to compare ps (of length n) with the first n elements of i:is. If they match, we then need to compare the remaining elements of i:is (of length nn) with a list containing nn copies of p. This code would probably be the same as in the below case, and I think a common function could be used.

TBD: how to record that input is a list or a pair? We should be able to check whether p is an atom, and if so, store a new variable named p in a new namespace (say, "nary") to indicate the input form.
       
DottedList / DottedList
-----------------------

Basically for a dotted list we:
- match all elements of ps with the first elements of is (of the same length as is)
- match remaining elements of is (and i) against p. This match needs to set a variable such as hasEllipsis (or a new one) to indicate that an atom in the pattern will be loaded up as a variable to unload during transformation

The second part of this match could either iterate over remaining i members, or it could construct a list of i members as well as a corresponding list of the same length (0 to n) but each member is p. Then could just use loadLocal to process both lists (TBD: I *think* this would work)


transform
---------
TBD
