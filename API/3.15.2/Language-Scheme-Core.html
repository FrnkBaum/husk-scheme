<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Language.Scheme.Core</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Language-Scheme-Core.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">husk-scheme-3.15.2: R5RS Scheme interpreter, compiler, and library.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>portable</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>github.com/justinethier</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Language.Scheme.Core</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Scheme code evaluation
</a></li><li><a href="#g:2">Core data
</a></li><li><a href="#g:3">Utility functions
</a></li><li><a href="#g:4">Internal use only
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains Core functionality, primarily Scheme expression evaluation.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:evalLisp">evalLisp</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:evalLisp-39-">evalLisp'</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; IO (<a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)</li><li class="src short"><a href="#v:evalString">evalString</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; String -&gt; IO String</li><li class="src short"><a href="#v:evalAndPrint">evalAndPrint</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; String -&gt; IO ()</li><li class="src short"><a href="#v:apply">apply</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:continueEval">continueEval</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:runIOThrows">runIOThrows</a> :: <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> String -&gt; IO (Maybe String)</li><li class="src short"><a href="#v:runIOThrowsREPL">runIOThrowsREPL</a> :: <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> String -&gt; IO String</li><li class="src short"><a href="#v:nullEnvWithImport">nullEnvWithImport</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li class="src short"><a href="#v:primitiveBindings">primitiveBindings</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li class="src short"><a href="#v:r5rsEnv">r5rsEnv</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li class="src short"><a href="#v:r5rsEnv-39-">r5rsEnv'</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li class="src short"><a href="#v:r7rsEnv">r7rsEnv</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li class="src short"><a href="#v:r7rsEnv-39-">r7rsEnv'</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li class="src short"><a href="#v:r7rsTimeEnv">r7rsTimeEnv</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li class="src short"><a href="#v:version">version</a> :: String</li><li class="src short"><a href="#v:findFileOrLib">findFileOrLib</a> :: [Char] -&gt; ErrorT <a href="Language-Scheme-Types.html#t:LispError">LispError</a> IO String</li><li class="src short"><a href="#v:getDataFileFullPath">getDataFileFullPath</a> :: String -&gt; IO String</li><li class="src short"><a href="#v:replaceAtIndex">replaceAtIndex</a> :: <span class="keyword">forall</span> a.  Int -&gt; a -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:registerExtensions">registerExtensions</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; (FilePath -&gt; IO FilePath) -&gt; IO ()</li><li class="src short"><a href="#v:showBanner">showBanner</a> :: IO ()</li><li class="src short"><a href="#v:showLispError">showLispError</a> :: <a href="Language-Scheme-Types.html#t:LispError">LispError</a> -&gt; IO String</li><li class="src short"><a href="#v:substr">substr</a> :: (<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>, <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>, <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:updateList">updateList</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:updateVector">updateVector</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:updateByteVector">updateByteVector</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:meval">meval</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li></ul></div><div id="interface"><h1 id="g:1">Scheme code evaluation
</h1><div class="top"><p class="src"><a name="v:evalLisp" class="def">evalLisp</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>Evaluate a lisp data structure and return a value for use by husk
</p></div></div><div class="top"><p class="src"><a name="v:evalLisp-39-" class="def">evalLisp'</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; IO (<a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)</p><div class="doc"><p>Evaluate a lisp data structure and return the LispVal or LispError
  result directly
</p><pre>
  result &lt;- evalLisp' env $ List [Atom <a href="/.html">/</a>, Number 1, Number 0]
  case result of
    Left err -&gt; putStrLn $ <a href="Error: .html">Error: </a> ++ (show err)
    Right val -&gt; putStrLn $ show val
</pre></div></div><div class="top"><p class="src"><a name="v:evalString" class="def">evalString</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; String -&gt; IO String</p><div class="doc"><p>Evaluate a string containing Scheme code
</p><pre>
env &lt;- primitiveBindings

evalString env <a href="(+ x x x).html">(+ x x x)</a>
<a href="3.html">3</a>

evalString env <a href="(+ x x x (* 3 9)).html">(+ x x x (* 3 9))</a>
<a href="30.html">30</a>

evalString env <a href="(* 3 9).html">(* 3 9)</a>
<a href="27.html">27</a>
</pre></div></div><div class="top"><p class="src"><a name="v:evalAndPrint" class="def">evalAndPrint</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; String -&gt; IO ()</p><div class="doc"><p>Evaluate a string and print results to console
</p></div></div><div class="top"><p class="src"><a name="v:apply" class="def">apply</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Current continuation
</p></td></tr><tr><td class="src">-&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Function or continuation to execute
</p></td></tr><tr><td class="src">-&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</td><td class="doc"><p>Arguments
</p></td></tr><tr><td class="src">-&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Final value of computation
</p></td></tr></table></div><div class="doc"><p>Call into a Scheme function
</p></div></div><div class="top"><p class="src"><a name="v:continueEval" class="def">continueEval</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Language-Scheme-Types.html#t:Env">Env</a></td><td class="doc"><p>Current environment
</p></td></tr><tr><td class="src">-&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Current continuation
</p></td></tr><tr><td class="src">-&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Value of previous computation
</p></td></tr><tr><td class="src">-&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Final value of computation
</p></td></tr></table></div><div class="doc"><p>A support function for eval; eval calls into this function instead of 
    returning values directly. continueEval then uses the continuation 
    argument to manage program control flow.
</p></div></div><div class="top"><p class="src"><a name="v:runIOThrows" class="def">runIOThrows</a> :: <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> String -&gt; IO (Maybe String)</p><div class="doc"><p>Execute an IO action and return error or Nothing if no error was thrown.
</p></div></div><div class="top"><p class="src"><a name="v:runIOThrowsREPL" class="def">runIOThrowsREPL</a> :: <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> String -&gt; IO String</p><div class="doc"><p>Execute an IO action and return result or an error message.
  This is intended for use by a REPL, where a result is always
  needed regardless of type.
</p></div></div><h1 id="g:2">Core data
</h1><div class="top"><p class="src"><a name="v:nullEnvWithImport" class="def">nullEnvWithImport</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></p><div class="doc"><p>An empty environment with the %import function. This is presently
  just intended for internal use by the compiler.
</p></div></div><div class="top"><p class="src"><a name="v:primitiveBindings" class="def">primitiveBindings</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></p><div class="doc"><p>Environment containing the primitive forms that are built into the Scheme 
  language. This function only includes forms that are implemented in Haskell; 
  derived forms implemented in Scheme (such as let, list, etc) are available
  in the standard library which must be pulled into the environment using <em>(load)</em>
</p><p>For the purposes of using husk as an extension language, <em>r5rsEnv</em> will
  probably be more useful.
</p></div></div><div class="top"><p class="src"><a name="v:r5rsEnv" class="def">r5rsEnv</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></p><div class="doc"><p>Load the standard r5rs environment, including libraries
</p></div></div><div class="top"><p class="src"><a name="v:r5rsEnv-39-" class="def">r5rsEnv'</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></p><div class="doc"><p>Load the standard r5rs environment, including libraries,
  but do not create the (import) binding
</p></div></div><div class="top"><p class="src"><a name="v:r7rsEnv" class="def">r7rsEnv</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></p><div class="doc"><p>Load the standard r7rs environment, including libraries
</p><p>Note that the only difference between this and the r5rs equivalent is that
  slightly less Scheme code is loaded initially.
</p></div></div><div class="top"><p class="src"><a name="v:r7rsEnv-39-" class="def">r7rsEnv'</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></p><div class="doc"><p>Load the standard r7rs environment
</p></div></div><div class="top"><p class="src"><a name="v:r7rsTimeEnv" class="def">r7rsTimeEnv</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></p><div class="doc"><p>Load haskell bindings used for the r7rs time library
</p></div></div><div class="top"><p class="src"><a name="v:version" class="def">version</a> :: String</p><div class="doc"><p>husk version number
</p></div></div><h1 id="g:3">Utility functions
</h1><div class="top"><p class="src"><a name="v:findFileOrLib" class="def">findFileOrLib</a> :: [Char] -&gt; ErrorT <a href="Language-Scheme-Types.html#t:LispError">LispError</a> IO String</p><div class="doc"><p>Attempts to find the file both in the current directory and in the husk
  libraries. If the file is not found in the current directory but exists
  as a husk library, return the full path to the file in the library.
  Otherwise just return the given filename.
</p></div></div><div class="top"><p class="src"><a name="v:getDataFileFullPath" class="def">getDataFileFullPath</a> :: String -&gt; IO String</p><div class="doc"><p>Get the full path to a data file installed for husk
</p></div></div><div class="top"><p class="src"><a name="v:replaceAtIndex" class="def">replaceAtIndex</a> :: <span class="keyword">forall</span> a.  Int -&gt; a -&gt; [a] -&gt; [a]</p><div class="doc"><p>Replace a list element, by index. Taken from:
  http:<em></em>stackoverflow.com<em>questions</em>10133361/haskell-replace-element-in-list
</p></div></div><div class="top"><p class="src"><a name="v:registerExtensions" class="def">registerExtensions</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; (FilePath -&gt; IO FilePath) -&gt; IO ()</p><div class="doc"><p>Register optional SRFI extensions
</p></div></div><div class="top"><p class="src"><a name="v:showBanner" class="def">showBanner</a> :: IO ()</p><div class="doc"><p>A utility function to display the husk console banner
</p></div></div><div class="top"><p class="src"><a name="v:showLispError" class="def">showLispError</a> :: <a href="Language-Scheme-Types.html#t:LispError">LispError</a> -&gt; IO String</p><div class="doc"><p>This is the recommended function to use to display a lisp error, instead
  of just using show directly.
</p></div></div><div class="top"><p class="src"><a name="v:substr" class="def">substr</a> :: (<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>, <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>, <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>A helper function for the special form <em>(string-set!)</em>
</p></div></div><div class="top"><p class="src"><a name="v:updateList" class="def">updateList</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>A helper function for <em>(list-set!)</em>
</p></div></div><div class="top"><p class="src"><a name="v:updateVector" class="def">updateVector</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>A helper function for the special form <em>(vector-set!)</em>
</p></div></div><div class="top"><p class="src"><a name="v:updateByteVector" class="def">updateByteVector</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>A helper function for the special form <em>(bytevector-u8-set!)</em>
</p></div></div><h1 id="g:4">Internal use only
</h1><div class="top"><p class="src"><a name="v:meval" class="def">meval</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>A wrapper for macroEval and eval
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>