<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Language.Scheme.Types</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Language-Scheme-Types.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">husk-scheme-3.7: R5RS Scheme interpreter, compiler, and library.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>portable</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>github.com/justinethier</td></tr><tr><th>Safe Haskell</th><td>Safe-Infered</td></tr></table><p class="caption">Language.Scheme.Types</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Environments
</a></li><li><a href="#g:2">Error Handling
</a></li><li><a href="#g:3">Types and related functions
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains top-level data type definitions, environments, error types, and associated functions.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Env">Env</a>  = <a href="#v:Environment">Environment</a> {<ul class="subs"><li><a href="#v:parentEnv">parentEnv</a> :: Maybe <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li><a href="#v:bindings">bindings</a> :: IORef (Map String (IORef <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>))</li><li><a href="#v:pointers">pointers</a> :: IORef (Map String (IORef [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]))</li></ul>}</li><li class="src short"><a href="#v:nullEnv">nullEnv</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:LispError">LispError</a> <ul class="subs"><li>= <a href="#v:NumArgs">NumArgs</a> (Maybe Integer) [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]  </li><li>| <a href="#v:TypeMismatch">TypeMismatch</a> String <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>  </li><li>| <a href="#v:Parser">Parser</a> ParseError  </li><li>| <a href="#v:BadSpecialForm">BadSpecialForm</a> String <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>  </li><li>| <a href="#v:UnboundVar">UnboundVar</a> String String  </li><li>| <a href="#v:DivideByZero">DivideByZero</a>  </li><li>| <a href="#v:NotImplemented">NotImplemented</a> String  </li><li>| <a href="#v:InternalError">InternalError</a> String  </li><li>| <a href="#v:Default">Default</a> String  </li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:ThrowsError">ThrowsError</a> = Either <a href="Language-Scheme-Types.html#t:LispError">LispError</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:IOThrowsError">IOThrowsError</a> = ErrorT <a href="Language-Scheme-Types.html#t:LispError">LispError</a> IO</li><li class="src short"><a href="#v:trapError">trapError</a> :: (MonadError e m, Show e) =&gt; m String -&gt; m String</li><li class="src short"><a href="#v:extractValue">extractValue</a> ::  <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> a -&gt; a</li><li class="src short"><a href="#v:liftThrows">liftThrows</a> ::  <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> a -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> a</li><li class="src short"><a href="#v:runIOThrowsREPL">runIOThrowsREPL</a> :: <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> String -&gt; IO String</li><li class="src short"><a href="#v:runIOThrows">runIOThrows</a> :: <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> String -&gt; IO (Maybe String)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:LispVal">LispVal</a> <ul class="subs"><li>= <a href="#v:Atom">Atom</a> String  </li><li>| <a href="#v:List">List</a> [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]  </li><li>| <a href="#v:DottedList">DottedList</a> [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>  </li><li>| <a href="#v:Vector">Vector</a> (Array Int <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)  </li><li>| <a href="#v:ByteVector">ByteVector</a> ByteString  </li><li>| <a href="#v:HashTable">HashTable</a> (Map <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)  </li><li>| <a href="#v:Number">Number</a> Integer  </li><li>| <a href="#v:Float">Float</a> Double  </li><li>| <a href="#v:Complex">Complex</a> (Complex Double)  </li><li>| <a href="#v:Rational">Rational</a> Rational  </li><li>| <a href="#v:String">String</a> String  </li><li>| <a href="#v:Char">Char</a> Char  </li><li>| <a href="#v:Bool">Bool</a> Bool  </li><li>| <a href="#v:PrimitiveFunc">PrimitiveFunc</a> ([<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)  </li><li>| <a href="#v:Func">Func</a> { <ul class="subs"><li><a href="#v:params">params</a> :: [String]</li><li><a href="#v:vararg">vararg</a> :: Maybe String</li><li><a href="#v:body">body</a> :: [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</li><li><a href="#v:closure">closure</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a></li></ul> }</li><li>| <a href="#v:HFunc">HFunc</a> { <ul class="subs"><li><a href="#v:hparams">hparams</a> :: [String]</li><li><a href="#v:hvararg">hvararg</a> :: Maybe String</li><li><a href="#v:hbody">hbody</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li><a href="#v:hclosure">hclosure</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a></li></ul> }</li><li>| <a href="#v:IOFunc">IOFunc</a> ([<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)  </li><li>| <a href="#v:EvalFunc">EvalFunc</a> ([<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)  </li><li>| <a href="#v:Pointer">Pointer</a> { <ul class="subs"><li><a href="#v:pointerVar">pointerVar</a> :: String</li><li><a href="#v:pointerEnv">pointerEnv</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a></li></ul> }</li><li>| <a href="#v:Opaque">Opaque</a> Dynamic  </li><li>| <a href="#v:Port">Port</a> Handle  </li><li>| <a href="#v:Continuation">Continuation</a> { <ul class="subs"><li><a href="#v:contClosure">contClosure</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li><a href="#v:currentCont">currentCont</a> :: Maybe <a href="Language-Scheme-Types.html#t:DeferredCode">DeferredCode</a></li><li><a href="#v:nextCont">nextCont</a> :: Maybe <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li><a href="#v:extraReturnArgs">extraReturnArgs</a> :: Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</li><li><a href="#v:dynamicWind">dynamicWind</a> :: Maybe [<a href="Language-Scheme-Types.html#t:DynamicWinders">DynamicWinders</a>]</li></ul> }</li><li>| <a href="#v:Syntax">Syntax</a> { <ul class="subs"><li><a href="#v:synClosure">synClosure</a> :: Maybe <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li><a href="#v:synRenameClosure">synRenameClosure</a> :: Maybe <a href="Language-Scheme-Types.html#t:Env">Env</a></li><li><a href="#v:synDefinedInMacro">synDefinedInMacro</a> :: Bool</li><li><a href="#v:synIdentifiers">synIdentifiers</a> :: [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</li><li><a href="#v:synRules">synRules</a> :: [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</li></ul> }</li><li>| <a href="#v:SyntaxExplicitRenaming">SyntaxExplicitRenaming</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>  </li><li>| <a href="#v:LispEnv">LispEnv</a> <a href="Language-Scheme-Types.html#t:Env">Env</a>  </li><li>| <a href="#v:EOF">EOF</a>  </li><li>| <a href="#v:Nil">Nil</a> String  </li></ul></li><li class="src short"><a href="#v:toOpaque">toOpaque</a> :: Typeable a =&gt; a -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:fromOpaque">fromOpaque</a> :: <span class="keyword">forall</span> a. Typeable a =&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> a</li><li class="src short"><span class="keyword">data</span>  <a href="#t:DeferredCode">DeferredCode</a> <ul class="subs"><li>= <a href="#v:SchemeBody">SchemeBody</a> [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]  </li><li>| <a href="#v:HaskellBody">HaskellBody</a> { <ul class="subs"><li><a href="#v:contFunction">contFunction</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li><a href="#v:contFunctionArgs">contFunctionArgs</a> :: Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</li></ul> }</li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:DynamicWinders">DynamicWinders</a>  = <a href="#v:DynamicWinders">DynamicWinders</a> {<ul class="subs"><li><a href="#v:before">before</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li><a href="#v:after">after</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li></ul>}</li><li class="src short"><a href="#v:makeNullContinuation">makeNullContinuation</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:makeCPS">makeCPS</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; (<a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:makeCPSWArgs">makeCPSWArgs</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; (<a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:eqv">eqv</a> :: [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:eqvList">eqvList</a> :: ([<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:eqVal">eqVal</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Bool</li><li class="src short"><a href="#v:makeFunc">makeFunc</a> :: Monad m =&gt; Maybe String -&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:makeNormalFunc">makeNormalFunc</a> :: Monad m =&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:makeVarargs">makeVarargs</a> :: Monad m =&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:makeHFunc">makeHFunc</a> :: Monad m =&gt; Maybe String -&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [String] -&gt; (<a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:makeNormalHFunc">makeNormalHFunc</a> :: Monad m =&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [String] -&gt; (<a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li><li class="src short"><a href="#v:makeHVarargs">makeHVarargs</a> :: Monad m =&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [String] -&gt; (<a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></li></ul></div><div id="interface"><h1 id="g:1">Environments
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Env" class="def">Env</a>  </p><div class="doc"><p>A Scheme environment containing variable bindings of form <code>(namespaceName, variableName), variableValue</code>
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Environment" class="def">Environment</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:parentEnv" class="def">parentEnv</a> :: Maybe <a href="Language-Scheme-Types.html#t:Env">Env</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:bindings" class="def">bindings</a> :: IORef (Map String (IORef <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>))</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:pointers" class="def">pointers</a> :: IORef (Map String (IORef [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]))</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:nullEnv" class="def">nullEnv</a> :: IO <a href="Language-Scheme-Types.html#t:Env">Env</a></p><div class="doc"><p>An empty environment
</p></div></div><h1 id="g:2">Error Handling
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:LispError" class="def">LispError</a>  </p><div class="doc"><p>Types of errors that may occur when evaluating Scheme code
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:NumArgs" class="def">NumArgs</a> (Maybe Integer) [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</td><td class="doc"><p>Invalid number of function arguments
</p></td></tr><tr><td class="src"><a name="v:TypeMismatch" class="def">TypeMismatch</a> String <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Type error
</p></td></tr><tr><td class="src"><a name="v:Parser" class="def">Parser</a> ParseError</td><td class="doc"><p>Parsing error
</p></td></tr><tr><td class="src"><a name="v:BadSpecialForm" class="def">BadSpecialForm</a> String <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Invalid special (built-in) form
  | NotFunction String String
</p></td></tr><tr><td class="src"><a name="v:UnboundVar" class="def">UnboundVar</a> String String</td><td class="doc"><p>A referenced variable has not been declared
</p></td></tr><tr><td class="src"><a name="v:DivideByZero" class="def">DivideByZero</a></td><td class="doc"><p>Divide by Zero error
</p></td></tr><tr><td class="src"><a name="v:NotImplemented" class="def">NotImplemented</a> String</td><td class="doc"><p>Feature is not implemented
</p></td></tr><tr><td class="src"><a name="v:InternalError" class="def">InternalError</a> String</td><td class="doc"><p>An internal error within husk; in theory user (Scheme) code
                         should never allow one of these errors to be triggered. 
</p></td></tr><tr><td class="src"><a name="v:Default" class="def">Default</a> String</td><td class="doc"><p>Default error
</p></td></tr></table></div><div class="subs instances"><p id="control.i:LispError" class="caption collapser" onclick="toggleSection('i:LispError')">Instances</p><div id="section.i:LispError" class="show"><table><tr><td class="src">Show <a href="Language-Scheme-Types.html#t:LispError">LispError</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Error <a href="Language-Scheme-Types.html#t:LispError">LispError</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:ThrowsError" class="def">ThrowsError</a> = Either <a href="Language-Scheme-Types.html#t:LispError">LispError</a></p><div class="doc"><p>Container used by operations that could throw an error
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:IOThrowsError" class="def">IOThrowsError</a> = ErrorT <a href="Language-Scheme-Types.html#t:LispError">LispError</a> IO</p><div class="doc"><p>Container used to provide error handling in the IO monad
</p></div></div><div class="top"><p class="src"><a name="v:trapError" class="def">trapError</a> :: (MonadError e m, Show e) =&gt; m String -&gt; m String</p><div class="doc"><p>Error handler that returns a string description of any error
</p></div></div><div class="top"><p class="src"><a name="v:extractValue" class="def">extractValue</a> ::  <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> a -&gt; a</p><div class="doc"><p>Utility function to unwrap a value from ThrowsError
</p></div></div><div class="top"><p class="src"><a name="v:liftThrows" class="def">liftThrows</a> ::  <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> a -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> a</p><div class="doc"><p>Lift a ThrowsError into the IO monad
</p></div></div><div class="top"><p class="src"><a name="v:runIOThrowsREPL" class="def">runIOThrowsREPL</a> :: <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> String -&gt; IO String</p><div class="doc"><p>Execute an IO action and return result or an error message.
  This is intended for use by a REPL, where a result is always
  needed regardless of type.
</p></div></div><div class="top"><p class="src"><a name="v:runIOThrows" class="def">runIOThrows</a> :: <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> String -&gt; IO (Maybe String)</p><div class="doc"><p>Execute an IO action and return error or Nothing if no error was thrown.
</p></div></div><h1 id="g:3">Types and related functions
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:LispVal" class="def">LispVal</a>  </p><div class="doc"><p>Scheme data types
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Atom" class="def">Atom</a> String</td><td class="doc"><p>Symbol
</p></td></tr><tr><td class="src"><a name="v:List" class="def">List</a> [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</td><td class="doc"><p>List
</p></td></tr><tr><td class="src"><a name="v:DottedList" class="def">DottedList</a> [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Pair
</p></td></tr><tr><td class="src"><a name="v:Vector" class="def">Vector</a> (Array Int <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)</td><td class="doc"><p>Vector
</p></td></tr><tr><td class="src"><a name="v:ByteVector" class="def">ByteVector</a> ByteString</td><td class="doc"><p>ByteVector from R7RS
</p></td></tr><tr><td class="src"><a name="v:HashTable" class="def">HashTable</a> (Map <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)</td><td class="doc"><p>Hash table.
 Technically this could be a derived data type instead of being built-in to the
 interpreter. And perhaps in the future it will be. But for now, a hash table
 is too important of a data type to not be included. 
</p></td></tr><tr><td class="src"><a name="v:Number" class="def">Number</a> Integer</td><td class="doc"><p>Integer number
</p></td></tr><tr><td class="src"><a name="v:Float" class="def">Float</a> Double</td><td class="doc"><p>Double-precision floating point number
</p></td></tr><tr><td class="src"><a name="v:Complex" class="def">Complex</a> (Complex Double)</td><td class="doc"><p>Complex number
</p></td></tr><tr><td class="src"><a name="v:Rational" class="def">Rational</a> Rational</td><td class="doc"><p>Rational number
</p></td></tr><tr><td class="src"><a name="v:String" class="def">String</a> String</td><td class="doc"><p>String
</p></td></tr><tr><td class="src"><a name="v:Char" class="def">Char</a> Char</td><td class="doc"><p>Character
</p></td></tr><tr><td class="src"><a name="v:Bool" class="def">Bool</a> Bool</td><td class="doc"><p>Boolean
</p></td></tr><tr><td class="src"><a name="v:PrimitiveFunc" class="def">PrimitiveFunc</a> ([<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)</td><td class="doc"><p>Primitive function
</p></td></tr><tr><td class="src"><a name="v:Func" class="def">Func</a></td><td class="doc"><p>Function
</p></td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:params" class="def">params</a> :: [String]</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:vararg" class="def">vararg</a> :: Maybe String</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:body" class="def">body</a> :: [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:closure" class="def">closure</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr><tr><td class="src"><a name="v:HFunc" class="def">HFunc</a></td><td class="doc"><p>Function formed from a Haskell function
</p></td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:hparams" class="def">hparams</a> :: [String]</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:hvararg" class="def">hvararg</a> :: Maybe String</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:hbody" class="def">hbody</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:hclosure" class="def">hclosure</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr><tr><td class="src"><a name="v:IOFunc" class="def">IOFunc</a> ([<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)</td><td class="doc"><p>Primitive function within the IO monad
</p></td></tr><tr><td class="src"><a name="v:EvalFunc" class="def">EvalFunc</a> ([<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)</td><td class="doc"><p>Function within the IO monad with access to
 the current environment and continuation. 
</p></td></tr><tr><td class="src"><a name="v:Pointer" class="def">Pointer</a></td><td class="doc"><p>Pointer to an environment variable.
</p></td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:pointerVar" class="def">pointerVar</a> :: String</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:pointerEnv" class="def">pointerEnv</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr><tr><td class="src"><a name="v:Opaque" class="def">Opaque</a> Dynamic</td><td class="doc"><p>Opaque Haskell value.
</p></td></tr><tr><td class="src"><a name="v:Port" class="def">Port</a> Handle</td><td class="doc"><p>I/O port
</p></td></tr><tr><td class="src"><a name="v:Continuation" class="def">Continuation</a></td><td class="doc"><p>Continuation
</p></td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:contClosure" class="def">contClosure</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:currentCont" class="def">currentCont</a> :: Maybe <a href="Language-Scheme-Types.html#t:DeferredCode">DeferredCode</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:nextCont" class="def">nextCont</a> :: Maybe <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:extraReturnArgs" class="def">extraReturnArgs</a> :: Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:dynamicWind" class="def">dynamicWind</a> :: Maybe [<a href="Language-Scheme-Types.html#t:DynamicWinders">DynamicWinders</a>]</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr><tr><td class="src"><a name="v:Syntax" class="def">Syntax</a></td><td class="doc"><p>Type to hold a syntax object that is created by a macro definition.
   Syntax objects are not used like regular types in that they are not
   passed around within variables. In other words, you cannot use set! to
   assign a variable to a syntax object. But they are used during function
   application. In any case, it is convenient to define the type here 
   because syntax objects are stored in the same environments and 
   manipulated by the same functions as regular variables.
</p></td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:synClosure" class="def">synClosure</a> :: Maybe <a href="Language-Scheme-Types.html#t:Env">Env</a></dt><dd class="doc"><p>Code env in effect at definition time, if applicable
</p></dd><dt class="src"><a name="v:synRenameClosure" class="def">synRenameClosure</a> :: Maybe <a href="Language-Scheme-Types.html#t:Env">Env</a></dt><dd class="doc"><p>Renames (from macro hygiene) in effect at def time;
   only applicable if this macro defined inside another macro.
</p></dd><dt class="src"><a name="v:synDefinedInMacro" class="def">synDefinedInMacro</a> :: Bool</dt><dd class="doc"><p>Set if macro is defined within another macro
</p></dd><dt class="src"><a name="v:synIdentifiers" class="def">synIdentifiers</a> :: [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</dt><dd class="doc"><p>Literal identifiers from syntax-rules 
</p></dd><dt class="src"><a name="v:synRules" class="def">synRules</a> :: [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</dt><dd class="doc"><p>Rules from syntax-rules
</p></dd></dl><div class="clear"></div></div></td></tr><tr><td class="src"><a name="v:SyntaxExplicitRenaming" class="def">SyntaxExplicitRenaming</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Syntax for an explicit-renaming macro
</p></td></tr><tr><td class="src"><a name="v:LispEnv" class="def">LispEnv</a> <a href="Language-Scheme-Types.html#t:Env">Env</a></td><td class="doc"><p>Wrapper for a scheme environment
</p></td></tr><tr><td class="src"><a name="v:EOF" class="def">EOF</a></td><td class="doc"><p>End of file indicator
</p></td></tr><tr><td class="src"><a name="v:Nil" class="def">Nil</a> String</td><td class="doc"><p>Internal use only; do not use this type directly.
</p></td></tr></table></div><div class="subs instances"><p id="control.i:LispVal" class="caption collapser" onclick="toggleSection('i:LispVal')">Instances</p><div id="section.i:LispVal" class="show"><table><tr><td class="src">Eq <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Ord <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Show <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Allow conversion of lispval instances to strings
</p></td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:toOpaque" class="def">toOpaque</a> :: Typeable a =&gt; a -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>Convert a Haskell value to an opaque Lisp value.
</p></div></div><div class="top"><p class="src"><a name="v:fromOpaque" class="def">fromOpaque</a> :: <span class="keyword">forall</span> a. Typeable a =&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> a</p><div class="doc"><p>Convert an opaque Lisp value back into a Haskell value of the appropriate
  type, or produce a TypeMismatch error.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:DeferredCode" class="def">DeferredCode</a>  </p><div class="doc"><p>Container to hold code that is passed to a continuation for deferred execution
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:SchemeBody" class="def">SchemeBody</a> [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</td><td class="doc"><p>A block of Scheme code
</p></td></tr><tr><td class="src"><a name="v:HaskellBody" class="def">HaskellBody</a></td><td class="doc"><p>A Haskell function
</p></td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:contFunction" class="def">contFunction</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:contFunctionArgs" class="def">contFunctionArgs</a> :: Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:DynamicWinders" class="def">DynamicWinders</a>  </p><div class="doc"><p>Container to store information from a dynamic-wind
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DynamicWinders" class="def">DynamicWinders</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:before" class="def">before</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></dt><dd class="doc"><p>Function to execute when resuming continuation within extent of dynamic-wind
</p></dd><dt class="src"><a name="v:after" class="def">after</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></dt><dd class="doc"><p>Function to execute when leaving extent of dynamic-wind
</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:DynamicWinders" class="caption collapser" onclick="toggleSection('i:DynamicWinders')">Instances</p><div id="section.i:DynamicWinders" class="show"><table><tr><td class="src">Show <a href="Language-Scheme-Types.html#t:DynamicWinders">DynamicWinders</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:makeNullContinuation" class="def">makeNullContinuation</a> :: <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>Make an <a href="empty.html">empty</a> continuation that does not contain any code
</p></div></div><div class="top"><p class="src"><a name="v:makeCPS" class="def">makeCPS</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Language-Scheme-Types.html#t:Env">Env</a></td><td class="doc"><p>Environment
</p></td></tr><tr><td class="src">-&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Current continuation
</p></td></tr><tr><td class="src">-&gt; (<a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)</td><td class="doc"><p>Haskell function
</p></td></tr><tr><td class="src">-&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>The Haskell function packaged as a LispVal
</p></td></tr></table></div><div class="doc"><p>Make a continuation that takes a higher-order function (written in Haskell)
</p></div></div><div class="top"><p class="src"><a name="v:makeCPSWArgs" class="def">makeCPSWArgs</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Language-Scheme-Types.html#t:Env">Env</a></td><td class="doc"><p>Environment
</p></td></tr><tr><td class="src">-&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Current continuation
</p></td></tr><tr><td class="src">-&gt; (<a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>)</td><td class="doc"><p>Haskell function
</p></td></tr><tr><td class="src">-&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</td><td class="doc"><p>Arguments to the function
</p></td></tr><tr><td class="src">-&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>The Haskell function packaged as a LispVal
</p></td></tr></table></div><div class="doc"><p>Make a continuation that stores a higher-order function and arguments to that function
</p></div></div><div class="top"><p class="src"><a name="v:eqv" class="def">eqv</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>]</td><td class="doc"><p>A list containing two values to compare
</p></td></tr><tr><td class="src">-&gt; <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></td><td class="doc"><p>Result wrapped as a Bool
</p></td></tr></table></div><div class="doc"><p>Compare two <code><a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></code> instances
</p></div></div><div class="top"><p class="src"><a name="v:eqvList" class="def">eqvList</a> :: ([<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:ThrowsError">ThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>Compare two lists of haskell values, using the given comparison function
</p></div></div><div class="top"><p class="src"><a name="v:eqVal" class="def">eqVal</a> :: <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Bool</p><div class="doc"><p>A more convenient way to call <em>eqv</em>
</p></div></div><div class="top"><p class="src"><a name="v:makeFunc" class="def">makeFunc</a> :: Monad m =&gt; Maybe String -&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>Create a scheme function
</p></div></div><div class="top"><p class="src"><a name="v:makeNormalFunc" class="def">makeNormalFunc</a> :: Monad m =&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>Create a normal scheme function
</p></div></div><div class="top"><p class="src"><a name="v:makeVarargs" class="def">makeVarargs</a> :: Monad m =&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>Create a scheme function that can receive any number of arguments
</p></div></div><div class="top"><p class="src"><a name="v:makeHFunc" class="def">makeHFunc</a> :: Monad m =&gt; Maybe String -&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [String] -&gt; (<a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>Create a haskell function
</p></div></div><div class="top"><p class="src"><a name="v:makeNormalHFunc" class="def">makeNormalHFunc</a> :: Monad m =&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [String] -&gt; (<a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>Create a normal haskell function
</p></div></div><div class="top"><p class="src"><a name="v:makeHVarargs" class="def">makeHVarargs</a> :: Monad m =&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; [String] -&gt; (<a href="Language-Scheme-Types.html#t:Env">Env</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a> -&gt; Maybe [<a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>] -&gt; <a href="Language-Scheme-Types.html#t:IOThrowsError">IOThrowsError</a> <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a>) -&gt; m <a href="Language-Scheme-Types.html#t:LispVal">LispVal</a></p><div class="doc"><p>Create a haskell function that can receive any number of arguments
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.10.0</p></div></body></html>