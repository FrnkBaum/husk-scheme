;;;
;;; This file contains debug outputs from the 
;;; hello modules
;;;

;;
;; Code generated by a (define-library) definition:
;;
(let ((tmp *this-module*371))
  (define (rewrite-export x)
    (if (pair? x)
      (if (if (= 3 (length x)) (eq? 'rename (identifier->symbol (car x))) #f)
        (cons (car (cddr x)) (cadr x))
        (error "invalid module export" x))
      x))
  (define (extract-exports)
    ((lambda (temp471475)
       (if temp471475
         ((lambda (x476)
            (if (pair? (cdr x476))
              (error "export-all takes no parameters" x476))
            #f)
          temp471475)
         ((lambda ()
            ((lambda (f479486)
               ((lambda (ff481490)
                  ((lambda () (ff481490 *this-module*371 '()))))
                ((lambda (proc482493)
                   (f479486
                     (lambda (ls494 res495)
                       ((proc482493 proc482493) ls494 res495))))
                 (lambda (proc482496)
                   (f479486
                     (lambda (ls497 res498)
                       ((proc482496 proc482496) ls497 res498)))))))
             (lambda (lp499)
               (lambda (ls500 res501)
                 (if (null? ls500)
                   ((lambda () res501))
                   (if (if (pair? (car ls500)) (eq? 'export (caar ls500)) #f)
                     ((lambda ()
                        (lp499 (cdr ls500)
                               (append (map rewrite-export (cdar ls500)) res501))))
                     ((lambda () (lp499 (cdr ls500) res501))))))))))))
     (assq 'export-all *this-module*371)))
  (set! *this-module*371 '())
  (set! *this-module*371 (cons '(export lib1-hello) *this-module*371))
  (set! *this-module*371
    (cons '(import (scheme r5rs write) (libs lib2)) *this-module*371))
  (set! *this-module*371
    (cons '(begin
             (define (internal-func) (write lib2-hello))
             (define (lib1-hello) (internal-func)))
          *this-module*371))
  (set! *this-module*371 (reverse *this-module*371))
  (add-module!372
    '(libs lib1)
    (make-module (extract-exports) #f *this-module*371))
  (set! *this-module*371 tmp))

;;
;; Contents of *modules* in *meta-env*
;;
(((libs lib2)
  .
  #((lib2-hello)
    #f
    ((export lib2-hello) (begin (define lib2-hello "Hello from library #2")))
    #f))
 ((scheme r5rs write)
  .
  #((display write) #f ((export display write) (import (scheme r5rs))) #f))
 ((libs lib1)
  .
  #((lib1-hello)
    #f
    ((export lib1-hello)
     (import (scheme r5rs write) (libs lib2))
     (begin
       (define (internal-func) (write lib2-hello))
       (define (lib1-hello) (internal-func))))
    #f))
 ((scheme r5rs base)
  .
  #((* +
       -
       /
       <
       <=
       =
       >
       >=
       abs
       and
       append
       apply
       assoc
       assq
       assv
       begin
       boolean?
       bytevector
       bytevector-append
       bytevector-copy
       bytevector-copy!
       bytevector-length
       bytevector-u8-ref
       bytevector?
       caar
       cadr
       call-with-current-continuation
       call-with-values
       call/cc
       car
       case
       cdar
       cddr
       cdr
       ceiling
       char->integer
       char-ready?
       char<=?
       char<?
       char=?
       char>=?
       char>?
       char?
       close-input-port
       close-output-port
       complex?
       cond
       cons
       current-input-port
       current-output-port
       denominator
       do
       dynamic-wind
       eof-object?
       eq?
       equal?
       eqv?
       error
       even?
       exact->inexact
       expt
       floor
       for-each
       gcd
       import
       include
       include-ci
       inexact->exact
       input-port?
       integer->char
       integer?
       lcm
       length
       let
       let*
       letrec
       list
       list->string
       list->vector
       list-ref
       list-tail
       list?
       make-bytevector
       make-string
       make-vector
       map
       max
       member
       memq
       memv
       min
       modulo
       negative?
       newline
       not
       null?
       number->string
       number?
       numerator
       odd?
       or
       output-port?
       pair?
       peek-char
       positive?
       procedure?
       quasiquote
       quotient
       rational?
       rationalize
       read-char
       real?
       remainder
       reverse
       round
       string
       string->list
       string->number
       string->symbol
       string->utf8
       string-append
       string-copy
       string-length
       string-ref
       string<=?
       string<?
       string=?
       string>=?
       string>?
       string?
       substring
       symbol->string
       symbol?
       truncate
       utf8->string
       values
       vector
       vector->list
       vector-length
       vector-ref
       vector?
       write-char
       zero?)
    #f
    ((export
       *
       +
       -
       /
       <
       <=
       =
       >
       >=
       abs
       and
       append
       apply
       assoc
       assq
       assv
       begin
       boolean?
       bytevector
       bytevector-append
       bytevector-copy
       bytevector-copy!
       bytevector-length
       bytevector-u8-ref
       bytevector?
       caar
       cadr
       call-with-current-continuation
       call-with-values
       call/cc
       car
       case
       cdar
       cddr
       cdr
       ceiling
       char->integer
       char-ready?
       char<=?
       char<?
       char=?
       char>=?
       char>?
       char?
       close-input-port
       close-output-port
       complex?
       cond
       cons
       current-input-port
       current-output-port
       denominator
       do
       dynamic-wind
       eof-object?
       eq?
       equal?
       eqv?
       error
       even?
       exact->inexact
       expt
       floor
       for-each
       gcd
       import
       include
       include-ci
       inexact->exact
       input-port?
       integer->char
       integer?
       lcm
       length
       let
       let*
       letrec
       list
       list->string
       list->vector
       list-ref
       list-tail
       list?
       make-bytevector
       make-string
       make-vector
       map
       max
       member
       memq
       memv
       min
       modulo
       negative?
       newline
       not
       null?
       number->string
       number?
       numerator
       odd?
       or
       output-port?
       pair?
       peek-char
       positive?
       procedure?
       quasiquote
       quotient
       rational?
       rationalize
       read-char
       real?
       remainder
       reverse
       round
       string
       string->list
       string->number
       string->symbol
       string->utf8
       string-append
       string-copy
       string-length
       string-ref
       string<=?
       string<?
       string=?
       string>=?
       string>?
       string?
       substring
       symbol->string
       symbol?
       truncate
       utf8->string
       values
       vector
       vector->list
       vector-length
       vector-ref
       vector?
       write-char
       zero?)
     (import (scheme r5rs)))
    #f))
 ((scheme r5rs) . #(#f <env> () #f)))

