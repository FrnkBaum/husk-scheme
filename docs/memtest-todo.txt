TODO list for changes on this branch:

vector
 - vector-fill! should be able to be a library
   function, not a macro. put together an initial
   version but it fails both test cases
consider the following case, with or without the commented lines.
this seems to be the root problem
; ((lambda ()
  (define vec (vector 0 1 2 3 4))
  (vector-fill! vec 5)
  (write vec)
;  ))

also: 
(define a #f)
(define (test v) 
  (vector-set! v 0 #t)
  (set! a #t))
(let ((vec '#(0 1 2 3)))
;  (define vec (vector 0 1 2 3))
  (test vec)
  (write vec)
  (write a))

theory:
what is going in here is that there is no reason to
pass vec to the function's env, so when vector-set
searches for vec it never finds it. hence when we
write vec later on, it retains the original value.
in order for this to work we would need to pass an
env of use to the (test) function so that we can
update any bindings there if necessary.


 - may be edge cases to consider, such as 
   a vector passed directly to vector-set!
list
 - update type
 - interpreter support
 - compiler support
 - test suite
dottedlist
 - update type
 - interpreter support
 - compiler support
 - test suite
hashtable
 - update type
 - interpreter support
 - compiler support
 - test suite
string
 - update type
 - interpreter support
 - compiler support
 - test suite
