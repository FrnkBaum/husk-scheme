TODO list for changes on this branch:

vector
 - vector-fill! should be able to be a library
   function, not a macro. put together an initial
   version but it fails both test cases
consider the following case, with or without the commented lines.
this seems to be the root problem
; ((lambda ()
  (define vec (vector 0 1 2 3 4))
  (vector-fill! vec 5)
  (write vec)
;  ))

also: 
(define a #f)
(define (test v) 
  (vector-set! v 0 #t)
  (set! a #t))
(let ((vec '#(0 1 2 3)))
;  (define vec (vector 0 1 2 3))
  (test vec)
  (write vec)
  (write a))

TBD: is there a way to prove the below?

There must be an old copy of vec stored in the continuation
that is picked back up after returning from the call to
vector-fill! interesting that things work fine if execution 
is made at the top level. so where to go from here? is it
even possible to update that continuation?? can we re-arrange
how continuations use env's to somehow get this to work?
maybe we do not use the env from the continuation except in
special cases such as call/cc??

 - may be edge cases to consider, such as 
   a vector passed directly to vector-set!
list
 - update type
 - interpreter support
 - compiler support
 - test suite
dottedlist
 - update type
 - interpreter support
 - compiler support
 - test suite
hashtable
 - update type
 - interpreter support
 - compiler support
 - test suite
string
 - update type
 - interpreter support
 - compiler support
 - test suite
