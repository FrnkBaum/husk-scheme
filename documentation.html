---
title: husk scheme
menu: docs
---
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--

husk scheme

Copyright   : Justin Ethier
Licence     : MIT (see LICENSE in the distribution)
Maintainer  : github.com/justinethier

-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>husk Î» scheme</title>
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <link rel="shortcut icon" href="favicon.ico" />
    <link href="default.css" rel="stylesheet" type="text/css" />
    <link href="pygments.css" rel="stylesheet" type="text/css" />
    {% include google-analytics.html %}
</head>
<body>
<div id="header">
</div>
    {% include menu.html %}
<hr />
<div id="page">
	<div id="content">
	<h1 class="title">Documentation</h1>
        <div>
            <!-- <h2>Contents</h2> -->
            <div><a href="#section-features">Features</a></div>
            <div><a href="#section-libs">Libraries and Extensions</a></div>
            <div><a href="#section-usage">Usage</a></div>
            <div><a href="#section-lang-ref">Scheme Language Reference</a></div>
            <div><a href="#section-api">Haskell API</a></div>
            <div><a href="#section-ffi">Foreign Function Interface</a></div>
            <div><a href="#section-macros">Macro Debugging</a></div>
        </div>

        <br />
        <br />

		<div>
            <h2 id="section-features" class="title">Features</h2>
            <p>
husk includes most features from R<sup>5</sup>RS, including:

<br />
<ul>
<li> Primitive data types and their standard forms, including string, char, numbers (integer, rational, floating point, and complex), list, pair, vector, and symbols
</li><li> Proper tail recursion
</li><li> Proper lexical scoping
</li><li> Conditionals: if, case, cond
</li><li> Sequencing: begin
</li><li> Iteration: do
</li><li> Quasi-quotation
</li><li> Delayed Execution: delay, force
</li><li> Binding constructs: let, named let, let*, letrec
</li><li> Assignment operations
</li><li> Basic IO functions
</li><li> Standard library of Scheme functions
</li><li> Read-Eval-Print-Loop (REPL) interpreter, with input driven by Haskeline to provide a rich user experience
</li><li> Full numeric tower: includes support for parsing/storing types (exact, inexact, etc), support for operations on these types as well as mixing types and other constraints from the R<sup>5</sup>RS specification
</li><li> Continuations: First-class continuations of unlimited extent, call/cc, and call-with-values
</li><li> Hygienic Macros: High-level macros via define-syntax, let-syntax, and letrec-syntax
</li>
</ul>
And the following R<sup>7</sup>RS draft features:
<ul>
    <li>Nested block comments using #| and |#</li>
</ul>
</p>
            <h2 id="section-libs" class="title">Libraries and Extensions</h2>
<p>
The following standard libraries are supported:
<ul>
    <li>
        <a href="http://srfi.schemers.org/srfi-1/srfi-1.html">SRFI 1</a>: List Library - a comprehensive set of list-processing procedures. 
        This library is not included by default, it must be loaded using 
        <strong>(require-extension (srfi 1))</strong>.
    </li>
    <li><a href="http://srfi.schemers.org/srfi-23/srfi-23.html">SRFI 23</a>: Error reporting mechanism.</li>
    <li><a href="http://srfi.schemers.org/srfi-55/srfi-55.html">SRFI 55</a>: <strong>require-extension</strong> - an extremely simple facility for making an extension or library available to a Scheme toplevel environment.</li>
    <li><a href="http://srfi.schemers.org/srfi-69/srfi-69.html">SRFI 69</a>: Hash tables.</li>
</ul>
</p>
            <h2 id="section-usage" class="title">Usage</h2>
            <p>
                The interpreter may be invoked by running it directly from the command line:

                {% highlight console %}
./huski
                {% endhighlight %}

                Alternatively, you may run an individual scheme program:

                {% highlight console %}
./huski my-scheme-file.scm
                {% endhighlight %}
</p>

<h2 id="section-lang-ref" class="title">Scheme Language Reference</h2>
<p>
For full R<sup>5</sup>RS language documentation and API, please see the <a href="http://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-2.html#%_toc_start">online reference at schemers.org</a>.

The goal of husk is to implement the full R<sup>5</sup>RS Scheme language, except for selected compatibility issues as noted <a href="https://github.com/justinethier/husk-scheme/wiki/Compatibility">on the husk wiki</a>. If you see a part of the language that is not implemented or that does not follow the R<sup>5</sup>RS language, please report it as a bug.
</p>

<!--
<h2 class="title">Non-standard Scheme Extensions</h2>
<p> gensym, others? </p>
-->

<h2 id="section-api" class="title">Haskell API</h2>
<p>
A Haskell API is provided to allow you to embed a Scheme interpreter within a Haskell program. The key API modules are:

<ul>
    <li><a href="http://hackage.haskell.org/packages/archive/husk-scheme/latest/doc/html/Language-Scheme-Core.html">Language.Scheme.Core</a> - Contains functions to evaluate (execute) Scheme code</li>
    <li><a href="http://hackage.haskell.org/packages/archive/husk-scheme/latest/doc/html/Language-Scheme-Types.html">Language.Scheme.Types</a> - Contains Haskell data types used to represent Scheme primitives</li>
</ul>

The full API documentation is available online by release number - <a href="API/3.5.5/index.html">3.5.5</a>. You may also run <strong>make doc</strong> to generate API documentation directly from the source code. 

<br />
<br />

Finally, see <strong>shell.hs</strong> in the husk source code for a quick example of how you might get started using the API.
</p>

<h2 id="section-ffi" class="title">Foreign Function Interface</h2>
<p>
A foreign function interface (FFI) is provided to allow husk to call into arbitrary Haskell code. The interface is currently available via the <strong>load-ffi</strong> function:

                {% highlight scheme %}
(load-ffi "Language.Scheme.Plugins.CPUTime" "precision" "cpu-time:precision")
                {% endhighlight %}

<strong>load-ffi</strong> accepts the following string arguments:

<ul>
    <li>Name of a Haskell module to dynamically load</li>
    <li>Haskell function to load from that module</li>
    <li>Name to use for the function after it is loaded into husk</li>
</ul>

From the previous example, once <strong>cpu-time:precision</strong> is loaded, it may be called directly from husk just like a regular Scheme function:

                {% highlight scheme %}
(cpu-time:precision)
                {% endhighlight %}

Any Haskell function loaded via the FFI must be of the following type:

                {% highlight haskell %}
    [LispVal] -> IOThrowsError LispVal
                {% endhighlight %}

See husk's <a href="http://hackage.haskell.org/packages/archive/husk-scheme/3.5.2.1/doc/html/Language-Scheme-Plugins-CPUTime.html">Language.Scheme.Plugins.CPUTime</a> module for an example of how to use the husk FFI.
</p>

<h2 id="section-macros" class="title">Macro Debugging</h2>
<p>
A custom special form <strong>expand</strong> can be used to see the result of a macro expansion, for debugging purposes.
For example, we can see that the <strong>let*</strong> expression

                {% highlight scheme %}
(expand 
  (let* ((x 42)
         (y x))
    y))
                {% endhighlight %}

is transformed into

                {% highlight scheme %}
((lambda (x30) ((lambda (y34) ((lambda () y34))) x30)) 42)
                {% endhighlight %}
                 
Note that any variables in the expanded code are renamed by husk's macro hygiene algorithm.
</p>
		</div>
	</div>
    {% include sidebar.html %}
</div>
<hr />
<div id="footer">
    {% include footer.html %}
</div>
</body>
</html>
