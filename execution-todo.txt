Design notes regarding TCO. The intent here is to think through these changes at a higher level
prior to implementation. There is a lot that I would like to cover here, including proper
tail recursion and continuations, and it should be done right (or as close a possible :)


Thinking about, from a design perspective does it make sense to have a trampoline that calls into
eval. eval would then return intermediate results at each step as a lambda, and the trampoline would
'bounce' them back up until a value is returned. This approach seems inefficient in terms of run time
but I think would allow for tail calls (but is more TCO required?). Need to consider how continuations
would fit in. Also, do I need to explicitly keep track of the stack? Maybe not because the lambda already
stores enough information?

Some links to drive this thinking:
http://mail.python.org/pipermail/tutor/2004-August/031553.html



Important notes from http://paulbarry.com/articles/2009/09/02/infinite-recursion

TCO isn't just about self-calling. I think the following is expected to run forever in scheme (forgive my poor scheme) but has no equivalent in Clojure, hence Clojure doesn't really have TCO (which it freely admits).

(define (foo) (bar))
(define (bar) (foo))
(foo)
